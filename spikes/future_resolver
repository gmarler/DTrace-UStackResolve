#!/usr/perl5/5.22.0/bin/perl

use strict;
use warnings;
use v5.22;

use IO::Async;
use IO::Async::Loop;
use IO::Async::FileStream;
use IO::Async::Channel;
use IO::Async::Stream;
use IO::Async::Function;
use IO::Async::Routine;
use Future::Utils qw( repeat fmap );
use CHI;
use Tree::RB              qw( LULTEQ );
use IO::File;
use Data::Dumper;

use Readonly;
# These are the array indices for symbol table entries
Readonly my $FUNCTION_NAME          => 0;
Readonly my $FUNCTION_START_ADDRESS => 1;
Readonly my $FUNCTION_SIZE          => 2;

my $output_dir = '/tmp';
my $cache_root = '/tmp/symbol_tables';

my $unresolved_file = '/tmp/DTrace-off-cpu-UNRESOLVED-20161107-CFvL';


my $unresolved_fh  = IO::File->new($unresolved_file, "<");

my $loop = IO::Async::Loop->new;

my $filestream = IO::Async::Stream->new(
  read_handle => $unresolved_fh,
  #on_initial => sub {
  #  my ($self, $filesize) = @_;
  #  $self->seek(0, SEEK_SET);
  #},
  on_read => sub {
    my ( $self, $buffref, $eof ) = @_;
    # as we read the file to resolve symbols in, we often need to know
    # what the current PID is for the data which follows to do an accurate
    # symbol table lookup
    my ($current_pid);

    # Read 1 to 50 lines at a time, as available
    while ( $$buffref =~ s/( (?: ^[^\n]+? \n) {1,50} )//smx ) {
      my $lines = $1;

      #if ($line =~ m/^PID:(?<pid>\d+)/) {
      #  $current_pid = $+{pid};
      #  # TODO: look this PID's entries up in at least the following
      #  #       namespaces, generating them asynchronously if necessary:
      #  # - ustack_resolve_pids
      #  # - symbol_table
      #  $resolved_fh->print( "$line\n" );
      #  next;
      #}
      #$line = $obj->_resolve_symbol( $direct_symbol_cache,
      #                               $symtab_trees_href,
      #                               $line, $current_pid );
      #$resolved_fh->print( "$line\n" );
      say "YEP: $lines";
    }

    # This might not be the cleanest way to go about this...
    if ($eof) {
      #if ($obj->dtrace_has_exited) {
      #  say "DTrace Script has exited, and read everything it produced - EXITING";
      #  exit(0);
      #}
      say "EOF detected";
      $loop->stop;
    }

    return 0;
  },
);

#$loop->add( $filestream );

#$loop->run;
#
my $driver_func = IO::Async::Function->new(
  code => \&driver,
);

my ($symtab_trees_href, $direct_symbol_cache);

my $resolver_func = IO::Async::Function->new(
  init_code   => \&init_cache,
  code        => \&resolver,
  min_workers => 8,
  max_workers => 8,
);

$loop->add( $resolver_func );

my ($RB_cache);

sub driver {
  my ($unresolved_file) = @_;

  my $unresolved_fh  = IO::File->new($unresolved_file, "<") or
    die "Unable to open $unresolved_file: $!";
  my $resolved = "/tmp/RESOLVED.out";
  my $resolved_fh = IO::File->new($resolved, ">") or
    die "Unable to open $resolved: $!";
  
  my ($c, $buf, $bytesread, $chunks, $lines);
  while ($bytesread = $unresolved_fh->sysread($buf, 65536)) {
    #say "READ $bytesread bytes";
    $c .= $buf; 
    my (@chunks);
    @chunks = $c =~ m{ ( (?: ^ [^\n]+? \n|^\n) {1,500} ) }gsmx;
  
    #$chunks += scalar(@chunks);
    #say scalar(@chunks) . " chunks read";
    my $eliminate_count =
      $c =~ s{ ( (?: ^ [^\n]+? \n|^\n) {1,500} ) }{}gsmx;

    my $f = fmap {
      my ($chunk) = @_;
      $resolver_func->call( args => [ $chunk ] );
    } foreach => \@chunks,
      concurrent => 20;
    my (@resolved_chunks) = $f->get;
    foreach my $chunk (@resolved_chunks) {
      $resolved_fh->print($chunk);
    }
  }
  
  $resolved_fh->close;
}



sub init_cache {
  $RB_cache =
    CHI->new(
              driver       => 'SharedMem',
              size         => 64 * 1024 * 1024,
              shmkey       => 12344322,
              namespace    => 'RedBlack_tree_symbol',
              global       => 0,
              on_get_error => 'warn',
              on_set_error => 'warn',
             );

  # CHI->new(
  #           driver       => 'BerkeleyDB',
  #           # No size specified
  #           # cache_size   => '8m',
  #           root_dir     => File::Spec->catfile( $output_dir, 'symbol_tables' ),
  #           namespace    => 'RedBlack_tree_symbol',
  #           global       => 0,
  #           on_get_error => 'warn',
  #           on_set_error => 'warn',
  #           l1_cache     => { driver   => 'RawMemory',
  #                             global   => 0,
  #                             # This is in terms of items, not bytes!
  #                             max_size => 256*1024,
  #                           }
  #          );

  #say "RB cache keys:\n" . join "\n", $RB_cache->get_keys();
  my $RB_keys_aref = [ $RB_cache->get_keys ];
  $symtab_trees_href =
    $RB_cache->get_multi_hashref($RB_keys_aref);
  # Initialize direct symbol lookup href
  $direct_symbol_cache = {};
}

sub resolver {
  my ($chunk) = @_;

  my ($resolved_chunk);
  my $unresolved_re =
    qr/^(?<keyfile>[^:]+):0x(?<offset>[\da-fA-F]+)/;

  while( $chunk =~ s/^(.*)\n// ) {
    my $line = $1;
    if ($line =~ m/^(?<keyfile>[^:]+):0x(?<offset>[\da-fA-F]+)$/) {
      # Return direct lookup if available
      if (exists($direct_symbol_cache->{$line})) {
        #return $direct_symbol_cache->{$line};
      }

      my ($keyfile, $offset) = ($+{keyfile}, hex( $+{offset} ) );
      if ( defined( my $search_tree = $symtab_trees_href->{$keyfile} ) ) {
        my $symtab_entry = $search_tree->lookup( $offset, LULTEQ );
        if (defined($symtab_entry)) {
          if (($offset >= $symtab_entry->[$FUNCTION_START_ADDRESS] ) and
              ($offset <= ($symtab_entry->[$FUNCTION_START_ADDRESS] +
                           $symtab_entry->[$FUNCTION_SIZE]) ) ) {
            my $resolved =
              sprintf("%s+0x%x",
                      $symtab_entry->[$FUNCTION_NAME],
                      $offset - $symtab_entry->[$FUNCTION_START_ADDRESS]);
            # If we got here, we have something to store in the direct symbol
            # lookup cache
            #$direct_symbol_cache->{$line} = $resolved;
            $line =~ s/^(?<keyfile>[^:]+):0x(?<offset>[\da-fA-F]+)$/${resolved}/;
          } else {
            $line .= " [SYMBOL TABLE LOOKUP FAILED - POTENTIAL MATCH FAILED]";
          }
        } else {
          $line .= " [SYMBOL TABLE LOOKUP FAILED - NOT EVEN A POTENTIAL MATCH]";
          #say "FAILED TO LOOKUP ENTRY FOR: $keyfile";
          #confess "WHAT THE HECK HAPPENED???";
        }
      } else {
        $line .= " [NO SYMBOL TABLE FOR $keyfile]";
      }
    }
    $resolved_chunk .= "$line\n";
  }

  return $resolved_chunk;
}


driver($unresolved_file);

say "DONE";

sleep(10);


#my $symtab_cache =
#  CHI->new(
#            driver       => 'BerkeleyDB',
#            cache_size   => '1024m',
#            root_dir     => File::Spec->catfile( $output_dir, 'symbol_tables' ),
#            namespace    => 'symbol_tables',
#            global       => 0,
#            on_get_error => 'warn',
#            on_set_error => 'warn',
#            l1_cache     => { driver   => 'RawMemory',
#                              global   => 0,
#                              # This is in terms of items, not bytes!
#                              max_size => 64*1024,
#                            }
#           );
#
#say "symtab cache keys:\n" . join "\n", $symtab_cache->get_keys();
#
#my $RB_cache =
#  CHI->new(
#            driver       => 'BerkeleyDB',
#            # No size specified
#            # cache_size   => '8m',
#            root_dir     => File::Spec->catfile( $output_dir, 'symbol_tables' ),
#            namespace    => 'RedBlack_tree_symbol',
#            global       => 0,
#            on_get_error => 'warn',
#            on_set_error => 'warn',
#            l1_cache     => { driver   => 'RawMemory',
#                              global   => 0,
#                              # This is in terms of items, not bytes!
#                              max_size => 128*1024,
#                            }
#           );
#
#say "RB cache keys:\n" . join "\n", $RB_cache->get_keys();
