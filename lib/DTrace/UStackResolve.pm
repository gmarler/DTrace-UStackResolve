package DTrace::UStackResolve;

use v5.22.0;
use strict;
use warnings;

use Moose;
use Moose::Util::TypeConstraints;
use MooseX::ClassAttribute;
use MooseX::Log::Log4perl;
use namespace::autoclean;
use File::Spec            qw();
use File::Basename        qw( basename );
use File::stat;
use File::ShareDir        qw( :ALL );
use File::Temp            qw();
use FindBin               qw( $Bin );
use Math::BigInt          qw();
use IO::File;
use IO::Async;
use IO::Async::Loop;
use IO::Async::FileStream;
use IO::Async::Function;
use IO::Async::Process;
use Future;
use Future::Utils         qw( fmap );
use List::Util            qw( first );
use List::MoreUtils       qw( uniq );
use List::BinarySearch    qw( );
use Tree::RB              qw( LULTEQ );
use CHI;
use Digest::SHA1          qw( );
use IPC::System::Simple   qw( capture $EXITVAL EXIT_ANY );
use Carp;
# Needs Exporter::ConditionalSubs
use Assert::Conditional  qw( :scalar );
use Socket                qw(SOL_SOCKET SO_RCVBUF SO_SNDBUF);
use Config;
use Readonly;
use Data::Dumper;


#
# CONSTANTS
#
# These are the array indices for symbol table entries
Readonly my $FUNCTION_NAME          => 0;
Readonly my $FUNCTION_START_ADDRESS => 1;
Readonly my $FUNCTION_SIZE          => 2;

our %dtrace_types = (
  "profile"         => "profile_pid.d",
  "profile_tid"     => "profile_pid_tid.d",
  "off-cpu"         => "off_cpu_profile_pid.d",
  "whatfor"         => "whatfor_pid.d",
  "whatfor_tid"     => "whatfor_pid_tid.d",
  "wakeup_chain"    => "wakeup_chain.d",
);

# NOTE: For use by IO::Async::Function resolver workers
my ($worker_symtab_trees_href, $worker_direct_symbol_cache, $no_annotations,
    $do_direct_lookups, $lookup_type, $obj);

#
# TODO: This module assumes use of a Perl with 64-bit ints.  Check for this, or
#       use Math::BigInt if it's missing.
#

# VERSION
#
# ABSTRACT: Resolve User Stacks from DTrace for Large Binaries

require XSLoader;

XSLoader::load('DTrace::UStackResolve', $VERSION);

=head1 SYNOPSIS

=head1 DESCRIPTON

With larger binaries, it's often the case that using DTrace's C<ustack()>
action will take very long amounts of time to complete the symbol table
lookups - often long enough to make DTrace abort because it appears
"unresponsive".

With the advent of this DTrace pragma:

#pragma D option noresolve

the output of the C<ustack()> action will be unresolved, for resolution
later.

The purpose of this module is to perform that resolution.

=head1 ATTRIBUTES

=cut

# Local Type Constraints

# So this will be recognized as a type in a Moose attribute 'isa' field
class_type 'IO::Async::Process';

subtype 'UStackDepthRange',
  as 'Int',
  where { $_ >= 1 && $_ <= 100 };

subtype 'CHI',
  as 'Object',
  where { blessed($_) =~ /^CHI::/ };

# Class Attribute Constants
class_has 'LDD' => (
  init_arg    => undef,
  is          => 'ro',
  isa         => 'Str',
  default     => "/bin/ldd",
);

class_has 'PLDD' => (
  init_arg    => undef,
  is          => 'ro',
  isa         => 'Str',
  default     => "/bin/pldd",
);

class_has 'PGREP' => (
  init_arg    => undef,
  is          => 'ro',
  isa         => 'Str',
  default     => "/bin/pgrep",
);

class_has 'ELFDUMP' => (
  init_arg    => undef,
  is          => 'ro',
  isa         => 'Str',
  default     => "/usr/bin/elfdump",
);

class_has 'DTRACE' => (
  init_arg    => undef,
  is          => 'ro',
  isa         => 'Str',
  default     => "/sbin/dtrace",
);

# Per Instance Attributes

#
# If set, save a copy of all of the intermediate/temporary files generated by
# this object
#
has 'preserve_tempfiles' => (
  is          => 'ro',
  isa         => 'Bool',
  default     => 0,
);

#
# If set (the default), use an additional optimization of a direct lookup cache
# for the most common <line> => <resolved symbol+offset> entries
#
has 'do_direct_lookups' => (
  is          => 'ro',
  isa         => 'Bool',
  default     => 1,
);

#
# If set, resolved output will NOT contain any commentary after unresolvable
# symbols
#
has 'no_annotations' => (
  is          => 'ro',
  isa         => 'Bool',
  default     => 0,
);

#
# the type of lookup desired - defaults to RedBlack, but can also be
# BinarySearch
#
has 'lookup_type' => (
  is          => 'ro',
  default     => RedBlack,
);

has 'datestamp' => (
  # generate YYYYMMDD datestamp
  init_arg    => undef,
  is          => 'ro',
  isa         => 'Str',
  default     =>
    sub {
      use POSIX qw(strftime);
      return strftime("%Y%02m%02d",localtime());
    },
  lazy        => 1,
);

has 'output_dir' => (
  is          => 'ro',
  isa         => 'Str',
  default     =>
    sub {
      my $self = shift;
      if (exists($self->{output_dir})) {
        return $self->{output_dir};
      } else {
        say "Defaulting to OUTPUT DIR of: /tmp";
        return "/tmp";
      }
    },
  lazy        => 1,
);

sub _sanity_check_output_dir {
  my ($self) = @_;

  confess "OUTPUT DIR [" . $self->output_dir . "] MUST EXIST"
    if ! -d $self->output_dir;
  confess "OUTPUT DIR [" . $self->output_dir . "] MUST BE WRITEABLE"
    if ! -w $self->output_dir;
}

has 'loop' => (
  is          => 'ro',
  isa         => 'IO::Async::Loop',
  builder     => '_build_loop',
  predicate   => '_has_loop',
  lazy        => 1,
);

#
# Will be passed a list of PIDs or a list of executable file names
# PIDs (live processes) and executables (a.outs) must be handled differently
#
# - A live process will immediately get all of the dynamic objects and their
#   symbols
#
# - Reading the symbol table from an a.out will only show the a.out object's
#   personal symbol table.  You must manually use ldd to extract all the
#   library names and then extract those symbol tables independently.
#

=method new()

The constructor takes the following attributes:

=for :list
* output_dir:              A Directory, which must already exist, in which to
                           store all temporary scratch files and output files
                           generated by this object.
                           Default /tmp

* execname or pid:         Full path to executable you want to get user stacks
                           for, OR, the PID of interest.
                           One is required, there is no default.

* type:                    The type of DTrace to run, from this list:
                           profile
                           off-cpu

* user_stack_frames:       The depth of the user stacks you want to receive
                           in the output.
                           Default: 100

* autoflush_dtrace_output: Whether to autoflush the DTrace output.
                           Defaults to 0 (false).  Good to enable for
                           scripts you expect slow/intermittent output from.

=cut

has 'execname' => (
  # NOTE: this will be an absolute path to the execname
  is          => 'ro',
  isa         => 'Str',
  #builder     => '_build_execname',
  #required    => 1,
);

# NOTE: The name DTrace puts in the ustack to identify the binary itself; often
#       is the name it was invoked with rather than it's real, true name
has 'personal_execname' => (
  # This will be a basename
  is          => 'ro',
  isa         => 'Maybe[Str]',
  lazy        => 1,
  default     => undef,
);


# Normally only set if profile is one that requires a tid
has 'tid'      => (
  # TODO: Unless the appropriate 'type' is specified (requiring a tid), just
  # note that the tid isn't being honored.
  is          => 'ro',
  isa         => 'Maybe[Int]',
  default     => undef,
);

has 'type'     => (
  is          => 'ro',
  isa         => 'Str',
  # TODO: Add a constraint to the available scripts
  default     => 'profile',
  lazy        => 1,
);

sub _sanity_check_type {
  my ($self) = @_;

  confess "Invalid DTrace type specified: " . $self->type
    unless (exists($dtrace_types{$self->type}));
}

# Flag to know when DTrace has exited, so we can know that the unresolved output
# file will no longer grow, and we can stop working when we reach the end of
# that file
has 'dtrace_has_exited' => (
  is          => 'rw',
  isa         => 'Bool',
  default     => 0,
);

#
# INPUT FILE ATTRIBUTES
#
# The contents of the DTrace template we will use
has 'dtrace_template_contents' => (
  is          => 'ro',
  isa         => 'Str',
  builder     => '_build_dtrace_template_contents',
  lazy        => 1,
);

# The contents of the DTrace script after the template has had it's keywords
# resolved
has 'dtrace_script_contents' => (
  is          => 'ro',
  isa         => 'Str',
  builder     => '_build_dtrace_script_contents',
  lazy        => 1,
);

# The filehandle for the temporary file that contains the DTrace script we've
# build from a template - DTrace will be handed the filename of this file to
# generate the unresolved output
has 'dtrace_script_fh' => (
  is          => 'ro',
  isa         => 'File::Temp',
  builder     => '_build_dtrace_script_fh',
  lazy        => 1,
  clearer     => 'clear_dtrace_script_fh',
);

# The IO::Async::Process for the dtrace process itself - used to ensure
# that the process actually dies upon destruction of this object
# TODO: Actually USE this to kill a leftover process
has 'dtrace_process' => (
  is          => 'rw',
  isa         => 'Undef|IO::Async::Process',
  default     => undef,
);

#
# OUTPUT FILE NAMES
#
# DTrace script output with unresolved stacks
has 'dscript_unresolved_out_fh' => (
  is          => 'rw',
  isa         => 'File::Temp',
  #builder     => '_build_dscript_unresolved_out',
  default     =>
    sub {
      my ($self) = shift;
      my ($output_dir)    = $self->output_dir;
      my ($dtrace_type)   = $self->type;
      my ($datestamp)     = $self->datestamp;

      confess "output_dir not set yet"
        if not defined($output_dir);

      my ($fh)   =
        File::Temp->new("DTrace-${dtrace_type}-UNRESOLVED-${datestamp}-XXXX",
                        DIR    => $output_dir,
                       );
      $fh->unlink_on_destroy( 0 ) if $self->preserve_tempfiles;
      say "UNRESOLVED USTACK OUTPUT FILE: " . $fh->filename;
      return $fh;
    },
  lazy        => 1,
  clearer     => 'clear_dscript_unresolved_out_fh',
);

# DTrace script Error output
has 'dscript_err_fh' => (
  is          => 'rw',
  isa         => 'File::Temp',
  #builder     => '_build_dscript_err',
  default     =>
    sub {
      my ($self) = shift;
      my ($output_dir)    = $self->output_dir;
      my ($dtrace_type)   = $self->type;
      my ($datestamp)     = $self->datestamp;

      confess "output_dir not set yet"
        if not defined($output_dir);

      my ($fh) =
        File::Temp->new(
          "DTrace-${dtrace_type}-UNRESOLVED-ERR-${datestamp}-XXXX",
          DIR    => $output_dir,
        );
      $fh->unlink_on_destroy( 0 ) if $self->preserve_tempfiles;
      return $fh;
    },
  lazy        => 1,
  clearer     => 'clear_dscript_err_fh',
);

# DTrace output with resolved ustacks
# NOTE: dependent on the exec_basename already being set
has 'resolved_out_fh' => (
  is          => 'ro',
  isa         => 'IO::File',
  lazy        => 1,
  builder     => '_build_resolved_out_fh',
);

sub _build_resolved_out_fh {
  my ($self) = shift;

  # NOTE: Since we can have multiple PIDs, just take the first one
  #       Maybe later we can split these out, if we care, and produce
  #       an array of resolved output files to write into
  my ($output_dir)    = $self->output_dir;
  my ($dtrace_type)   = $self->type;
  my ($datestamp)     = $self->datestamp;

  confess "output_dir not set yet"
    if not defined($output_dir);

  my ($pid)            = $self->pids->[0];
  my ($execname)       = $self->personal_execname;
  my ($resolved_fname) =
    File::Spec->catfile( $output_dir,
                         "$execname-${dtrace_type}.RESOLVED-${datestamp}");
  my ($resolved_fh)    = IO::File->new("$resolved_fname", ">>") or
    die "Unable to open $resolved_fname for writing";

  say "RESOLVED stacks in: $resolved_fname";
  return $resolved_fh;
}

# TODO: We actually should look at some way to uniquely identify the binary, as
#       that's the only thing whose changing matters.  Perhaps the inode?
#       Anything about the start time is irrelevant, other than knowing if it
#       changed, the on-disk file *might* have changed and should be checked,
#       and the cache possibly regenerated.
#       Also worth noting that any of the dynamic objects changing will also
#       require the cache for that object's file to be udpated
# The start time(s) of the execname we started this up
# for.  The point of this is to detect when the value increases,
# indicating that we need to recalculate the:
# - symbol cache
# - Red-Black or AA symbol lookup tree
# - direct lookup cache
has 'pid_starttime' => (
  is          => 'rw',
  isa         => 'HashRef[Int]',
  builder     => '_build_pid_starttime',
  lazy        => 1,
);

sub _build_pid_starttime {
  my ($self) = shift;

  my %start_times =
    map { $_ => $self->_get_pid_start_epoch($_); } @{$self->pids};
  return \%start_times;
}

has 'pids' => (
  is          => 'rw',
  isa         => 'ArrayRef[Int]',
  #builder     => '_build_pids',
  #required    => 1,
  #lazy        => 1,
);

has 'dynamic_library_paths' => (
  init_arg    => undef,   # don't allow specifying in the constructor
  is          => 'rw',
  isa         => 'ArrayRef[Str]',
  builder     => '_build_dynamic_library_paths',
  lazy        => 1,
  clearer     => '_clear_dynamic_library_paths',
  predicate   => '_has_dynamic_library_paths',
);

=head2  _build_dynamic_library_paths

This function processes the output of the pldd command on each PID of
interest, producing the absolute path of each dynamic library the PID has
loaded.

This is used as the list of libraries from which to extract symbol tables.

ldd on a non-running binary is sadly not sufficient for this, as won't go
through the whole library resolution process, and thus some libraries will be
omitted, as they're not yet known to be needed; so that's out.

=cut

sub _build_dynamic_library_paths {
  my ($self) = shift;
  my $pid_starttime_href = $self->pid_starttime;
  my $pldd_func          = $self->pldd_func;

  my $file_paths_f = fmap {
    my ($aref) = @_;
    my ($pid, $start_epoch) = @$aref;
    say "Obtaining list of dynamic libs for PID $pid";
    Future->done( $pldd_func->call( args => [ $pid, $start_epoch ] )->get );
  } foreach => [ map { [ $_, $pid_starttime_href->{$_} ] } keys %{$pid_starttime_href} ],
    concurrent => 8;

  my @file_paths = $file_paths_f->get;

  # Make sure the list of libraries is composed of unique members
  my @absolute_file_paths =
    uniq
    map { @$_ } @file_paths;

  # Shut down function worker processes/threads
  $pldd_func->stop;

  return \@absolute_file_paths;
}

has 'symbol_table' => (
  init_arg    => undef,   # don't allow specifying in the constructor
  is          => 'rw',
  isa         => 'HashRef[ArrayRef]',
  builder     => '_build_symbol_table',
  lazy        => 1,
  clearer     => '_clear_symbol_table',
  predicate   => '_has_symbol_table',
);

has 'inode_cache' => (
  init_arg    => undef,   # don't allow specifying in the constructor
  is          => 'ro',
  isa         => 'CHI',
  builder     => '_build_inode_cache',
  clearer     => 'clear_inode_cache',
  lazy        => 1,
);

has 'direct_symbol_cache' => (
  init_arg    => undef,   # don't allow specifying in the constructor
  is          => 'ro',
  isa         => 'CHI',
  builder     => '_build_direct_symbol_cache',
  clearer     => 'clear_direct_symbol_cache',
  lazy        => 1,
);


has 'symbol_table_cache' => (
  init_arg    => undef,   # don't allow specifying in the constructor
  is          => 'ro',
  isa         => 'CHI',
  builder     => '_build_symbol_table_cache',
  clearer     => 'clear_symbol_table_cache',
  lazy        => 1,
);

#
# The cache is built/reactivated on object creation - it is populated (if need
# be) during the BUILD part of this object, *after* the inode and
# symbol_table_cache have been fully populated
#
has 'RedBlack_tree_cache' => (
  init_arg    => undef,   # don't allow specifying in the constructor
  is          => 'ro',
  isa         => 'CHI',
  builder     => '_build_RedBlack_tree_cache',
  clearer     => 'clear_RedBlack_tree_cache',
  lazy        => 1,
);


#
# DTrace pragma settings that can be customized
#
has 'user_stack_frames' => (
  is          => 'ro',
  isa         => 'UStackDepthRange',
  # Allow user stack frame depth to be chosen, but default to 100, since
  # it's very likely we'll want the full user stack most of the time.
  default     => 100,
);

has 'bufsize' => (
  is          => 'ro',
  isa         => 'Str',
  default     => '8m',
);

has 'aggsize' => (
  is          => 'ro',
  isa         => 'Str',
  default     => '6m',
);

has 'aggrate' => (
  is          => 'ro',
  isa         => 'Str',
  default     => '23Hz',
);

has 'switchrate' => (
  is          => 'ro',
  isa         => 'Str',
  default     => '29Hz',
);

has 'cleanrate' => (
  is          => 'ro',
  isa         => 'Str',
  default     => '31Hz',
);

has 'dynvarsize' => (
  is          => 'ro',
  isa         => 'Str',
  default     => '32m',
);

has 'nworkers' => (
  is          => 'ro',
  isa         => 'Str',
  default     => '8',
);

has 'autoflush_dtrace_output' => (
  is          => 'ro',
  isa         => 'Num',
  default     => 0,
);

# How long the DTrace will run before exiting
# TODO: Sanity check any alteration in this value
has 'runtime' => (
  is          => 'ro',
  isa         => 'Str',
  default     => '1hour',
);


# TODO ATTRIBUTES:
# - autoflush of resolved stack output - to be used for scripts that produce
#   output slowly

sub _build_inode_cache {
  my ($self) = shift;

  my ($output_dir) = $self->output_dir;
  confess "output_dir not set yet"
    if not defined($output_dir);

  CHI->new(
            driver       => 'BerkeleyDB',
            root_dir     => File::Spec->catfile( $output_dir, 'symbol_tables' ),
            namespace    => 'inode',
            global       => 0,
            on_get_error => 'warn',
            on_set_error => 'warn',
           );
}

sub _build_symbol_table_cache {
  my ($self) = shift;

  my ($output_dir) = $self->output_dir;
  confess "output_dir not set yet"
    if not defined($output_dir);

  CHI->new(
            driver       => 'BerkeleyDB',
            cache_size   => '512m',
            root_dir     => File::Spec->catfile( $output_dir, 'symbol_tables' ),
            namespace    => 'symbol_tables',
            global       => 0,
            on_get_error => 'warn',
            on_set_error => 'warn',
            l1_cache     => { driver   => 'RawMemory',
                              global   => 0,
                              # This is in terms of items, not bytes!
                              max_size => 64*1024,
                            }
           );
}

sub _build_direct_symbol_cache {
  my ($self) = shift;

  my ($output_dir) = $self->output_dir;
  confess "output_dir not set yet"
    if not defined($output_dir);

  CHI->new(
            driver       => 'BerkeleyDB',
            cache_size   => '8m',
            root_dir     => File::Spec->catfile( $output_dir, 'symbol_tables' ),
            namespace    => 'direct_symbol',
            global       => 0,
            on_get_error => 'warn',
            on_set_error => 'warn',
            l1_cache     => { driver   => 'RawMemory',
                              global   => 0,
                              # This is in terms of items, not bytes!
                              max_size => 8*1024,
                            }
           );
}

sub _build_RedBlack_tree_cache {
  my ($self) = shift;

  my ($output_dir) = $self->output_dir;
  confess "output_dir not set yet"
    if not defined($output_dir);

  CHI->new(
            driver       => 'BerkeleyDB',
            # No size specified
            # cache_size   => '8m',
            root_dir     => File::Spec->catfile( $output_dir, 'symbol_tables' ),
            namespace    => 'RedBlack_tree_symbol',
            global       => 0,
            on_get_error => 'warn',
            on_set_error => 'warn',
            l1_cache     => { driver   => 'RawMemory',
                              global   => 0,
                              # This is in terms of items, not bytes!
                              max_size => 128*1024,
                            }
           );
}

sub _populate_RedBlack_tree_cache {
  my ($self) = shift;

  my ($symbol_table_cache)  = $self->symbol_table_cache;
  my ($RedBlack_tree_cache) = $self->RedBlack_tree_cache;
  my (%inserted_basenames);

  # serialize each symbol table separately, each stored under the
  # basename of the absolute path
  say "POPULATING RED-BLACK TREES FROM SYMBOL TABLES";
  foreach my $key ($symbol_table_cache->get_keys) {
    # This is the "short" key, which will match what DTrace's unresolved
    # address is usually prefixed with
    my ($basename_key) = basename($key);
    # At this point in building the object, if the key doesn't exist in the RB
    # Tree cache, it was removed and should be generated.  If it does exist,
    # it's very likely still valid and should be skipped.
    if ($RedBlack_tree_cache->is_valid($basename_key)) {
      # TODO: Log to debug log
      #say "RED BLACK TREE CACHE ENTRY ALREADY VALID FOR: $key";
      next;
    } else {
      say "BUILDING RED BLACK TREE FOR: $key";
      my $symtab_aref = $symbol_table_cache->get($key);
      my $tree = Tree::RB->new();
      foreach my $entry (@$symtab_aref) {
        $tree->put( $entry->[$FUNCTION_START_ADDRESS], $entry );
      }
      # Look for key duplicates of file basenames, as unlikely as they may
      # seem, to ensure we don't obliterate portions of symbol tables
      if (exists($inserted_basenames{$basename_key})) {
        say "WARNING: Looks like we're inserting a duplicate of: $basename_key";
      }
      $RedBlack_tree_cache->set($basename_key,$tree,'7 days');
      $inserted_basenames{$basename_key}++;
    }
  }
  # TODO: This seems to make accessing the RB Tree later *much* slower
  #       Might have been related to eliminating the L1 cache temporarily
  #       Try again.
  #$self->clear_symbol_table_cache;
}


# TODO: Add a test for constructor called with execname only and pids only
override BUILDARGS => sub {
  my $class = shift;

  if (exists($_[0]->{pids})) {
    # NOTE: The true absolute path to the executable is contained in procfs;
    #       however, the name the process knows itself as, and which it will
    #       report itself as in ustack before a colon is only visible via pargs,
    #       so we probably need to store both
    foreach my $pid (@{$_[0]->{pids}}) {
      my $a_out = "/proc/$pid/path/a.out";
      my ($abs_path) = readlink($a_out);
      if (not defined($abs_path)) {
        carp "could not open $a_out: $!";
      } else {
        $_[0]->{execname} = $abs_path;
      }
      # NOTE: Storing the basename only
      $_[0]->{personal_execname} = basename($abs_path);

      #my $pargs_out = capture( "/bin/pargs $pid" );
      #say "PARGS OUT: $pargs_out";
      #$pargs_out =~ m/^argv\[0\]:\s+(?<personal_execname>[^\n]+)/gsmx;
      #my $personal_execname = $+{personal_execname};
      ## NOTE: Storing the basename only
      #$_[0]->{personal_execname} = basename($personal_execname);
    }
  }

  return super;
};

#
# Next line is to ignore BUILD subroutine for POD coverage tests
#

=for Pod::Coverage BUILD

=cut

#
# This is where we define the order of attribute definition
#
sub BUILD {
  my ($self) = shift;

  # make $obj available for output_dir contents in _init_cache initialization of
  # IO::Async::Function for all worker threads
  # TODO: This may no longer be needed
  $obj = $self;
  # Ensure we have an output dir do put things in
  $self->output_dir;
  $self->datestamp;
  $self->_sanity_check_output_dir;
  $self->preserve_tempfiles;
  $self->user_stack_frames;
  #say "Building D Script Unresolved Output Filename: " .
  #  $self->dscript_unresolved_out;
  $self->_sanity_check_type;
  # Setup Async functions for later use
  $self->pldd_func;
  $self->sha1_func;
  $self->gen_symtab_func;
  $self->resolver_func;
  $self->loop;
  # TODO: Cleanup - Doesn't seem to be a builder here anymore
  $self->pids;
  $self->pid_starttime;
  # Actually gather dynamic library paths
  $self->dynamic_library_paths;
  say "GENERATING SYMBOL TABLE";
  $self->symbol_table;
  $self->inode_cache;
  $self->_populate_RedBlack_tree_cache;
  $self->type;
  $self->dtrace_template_contents;
  # Log to debug log
  #say "GENERATE personal execname: " .
  #  $self->personal_execname;
  $self->personal_execname;
  $self->dtrace_script_contents;
  $self->dtrace_script_fh;
  $self->dscript_unresolved_out_fh;
  $self->dscript_err_fh;
  $self->resolved_out_fh;
  #
  $self->_start_dtrace_capture;
  $self->start_stack_resolve;
}

=head1 METHODS

=cut

=method shared_libs_for_pid

The unresolved ustack()'s produced by DTrace are unfortunately not fully
qualified, so you're not sure where they're coming from, nor are you sure
whether you should be looking for the 32-bit or 64-bit variant of those
libraries (although you could likely deduce the latter easily).

This method performs a pldd on the selected PID, obtaining the fully qualified
pathnames for all shared libraries used by it.

TODO: Raise an exception if there is more than one library with the same
basename, as unresolved ustack() calls emit each user stack frame like so:

<library basename>:0x<hex address>

If there are duplicate basenames, we really need to know that, as they're
assumed to be unique throughout the system.

=cut



=method shared_libs_for_binary

Similar to shared_libs_for_pid, just does the same via ldd for a binary on disk,
rather than a live PID.

=cut

=head1 BUILDERS

=cut

has sha1_func => (
  is      => 'ro',
  isa     => 'IO::Async::Function',
  default => sub {
    return IO::Async::Function->new(
      code        => \&_file_sha1_digest,
    ),
  },
  lazy    => 1,
);

has pldd_func => (
  is      => 'ro',
  isa     => 'IO::Async::Function',
  default => sub {
    return IO::Async::Function->new(
      code        => \&_pid_dynamic_library_paths,
    ),
  },
  lazy    => 1,
);

has gen_symtab_func => (
  is      => 'ro',
  isa     => 'IO::Async::Function',
  default => sub {
    return IO::Async::Function->new(
      code        => \&_gen_symbol_table,
    ),
  },
  lazy    => 1,
);

has resolver_func => (
  is      => 'rw',
  isa     => 'Undef|IO::Async::Function',
  default => undef,
  lazy    => 1,
);


sub _build_loop {
  my ($self) = shift;

  my $loop = IO::Async::Loop->new;

  my $sha1_func       = $self->sha1_func;
  my $pldd_func       = $self->pldd_func;
  my $gen_symtab_func = $self->gen_symtab_func;
  # Not defined quite yet
  #my $resolver_func   = $self->resolver_func;

  $loop->add( $sha1_func );
  $loop->add( $pldd_func );
  $loop->add( $gen_symtab_func );
  # Have to add to loop after it's defined
  #$loop->add( $resolver_func );

  return $loop;
}

# sub _build_pids {
#   my ($self) = shift;
#
#   my (@pids);
#   my ($PGREP) = $self->PGREP;
#   my $execname = $self->execname;
#   # NOTE: On Solaris, if on global zone, pgrep will pick up the pid with this
#   #       execname in ALL zones unless you explicitly ask for the zone *you are
#   #       in*
#   my $zonename = capture( EXIT_ANY, "/bin/zonename" );
#   chomp($zonename);
#   my @output = capture( EXIT_ANY, "$PGREP -z $zonename -lxf '^$execname(.+)?'" );
#
#   if ($EXITVAL == 1) {
#     carp "No PIDs were found that match [$execname] !";
#     # TODO: should this croak or what?
#   } elsif ($EXITVAL == 0) {
#
#       chomp(@output);
#
#     say "PIDS:";
#     say join("\n",@output);
#     @pids = map { my $line = $_;
#                   $line =~ m/^(?:\s+)?(?<pid>\d+)\s+/;
#                   $+{pid}; } @output;
#   } else {
#     confess "pgrep returned $EXITVAL, which is a fatal exception for us";
#   }
#
#   return \@pids;
# }


# Given a path to a dynamic/shared library or an executable,
# generate the symbol table.
# The #pragma for noresolve ensures each generated symbol will be of the
# form <entity>:<offset from base of entity>
#
# This means that we can use the symbol table with base address assumed to be
# implicitly 0 to resolve symbols without further work.
#

# TODO: Turn this from a normal builder into a Future
# TODO: Change key from basename to absolute path; store basename as another key
#       or find another unique identifier
sub _build_symbol_table {
  my ($self) = shift;

  my ($inode_cache)         = $self->inode_cache;
  my ($symbol_table_cache)  = $self->symbol_table_cache;
  my ($RedBlack_tree_cache) = $self->RedBlack_tree_cache;
  my (@absolute_file_paths) = @{$self->dynamic_library_paths};
  my ($gen_symtab_func)     = $self->gen_symtab_func;
  # a.out
  my ($execpath)            = $self->execname;
  # Latest inodes for each filename
  my (%current_inodes);

  # Get the current inode for each file - this will change whenever the file
  # itself is changed/updated.
  foreach my $file (@absolute_file_paths, $execpath) {
    my $stat_obj = File::stat::stat($file);
    $current_inodes{$file} = $stat_obj->ino;
  }

  # Remove entries from this cache for absolute path names that no longer
  # exist
  foreach my $key ($symbol_table_cache->get_keys) {
    unless (-f $key) {
      say "REMOVING FROM CACHES DUE TO NO LONGER EXISTING: $key";
      $symbol_table_cache->remove($key);
      # ... and from the Red Black Tree cache, if the basename for it exists there
      my ($basename_key) = basename($key);
      if ($RedBlack_tree_cache->is_valid($basename_key)) {
        $RedBlack_tree_cache->remove($basename_key);
      }
    }
  }

  # Remove entries in the cache, if they exist, that no longer match
  # the original file inode the symtab was generated from
  foreach my $file_key (@absolute_file_paths, $execpath) {
    if ($symbol_table_cache->is_valid($file_key)) {
      # If the inode cache key for this file doesn't exist, remove it from the
      # symbol table cache, so the inode cache key *will* be generated
      if (not $inode_cache->is_valid($file_key)) {
        say "REMOVING SYMBOL TABLE CACHE BECAUSE NO INODE FOR: $file_key";
        $symbol_table_cache->remove($file_key);
        # Also remove Red-Black Tree Cache entry
        my ($basename_file_key) = basename($file_key);
        if ($RedBlack_tree_cache->is_valid($basename_file_key)) {
          $RedBlack_tree_cache->remove($basename_file_key);
        }
      } else {
        # If the inode cache key for this file does exist, do a comparison to make
        # sure it's still valid - remove if not
        my ($old_inode)     = $inode_cache->get($file_key);
        my ($current_inode) = $current_inodes{$file_key};
        if ($old_inode != $current_inode) {
          say "OLD INODE: $old_inode, CURRENT INODE: $current_inode";
          say "REMOVING SYMBOL TABLE CACHE FOR: $file_key";
          $symbol_table_cache->remove($file_key);
          # Also remove Red-Black Tree Cache entry
          my ($basename_file_key) = basename($file_key);
          if ($RedBlack_tree_cache->is_valid($basename_file_key)) {
            $RedBlack_tree_cache->remove($basename_file_key);
          }
        }
      }
    }
  }

  # Look for the symbol tables missing from the cache
  my @missing_symtab_cache_items =
    grep { not defined($symbol_table_cache->get($_)); }
      $execpath,         # Don't forget to add the a.out path too
      @absolute_file_paths;

  # If any entries are missing from the symtab cache, clear the same entries
  # (but by their basenames, rather than their absolute path names) from
  # the RedBlack tree cache
  if (scalar(@missing_symtab_cache_items)) {
    foreach my $absolute_path (@missing_symtab_cache_items) {
      my ($basename_path) = basename($absolute_path);
      if ($RedBlack_tree_cache->is_valid($basename_path)) {
        say "CLEARING RED BLACK TREE CACHE ENTRY FOR: $basename_path";
      }
    }
  }

  # Create the missing cache items
  my $symtabs_f = fmap {
    my ($absolute_path) = shift;
    #say "Creating symbol table for $absolute_path";
    # we cannot pass $self across the boundary as args
    Future->done(
        $absolute_path => $gen_symtab_func->call( args => [ $absolute_path ] )->get
    );
  } foreach => [
                 @missing_symtab_cache_items
               ], concurrent => 2;

  my %symtabs = $symtabs_f->get;

  # Shut down function worker processes/threads
  $gen_symtab_func->stop;

  foreach my $symtab_path (keys %symtabs) {
    # Store the data in the symbol table cache
    unless (defined($symbol_table_cache
                    ->set($symtab_path,
                          $symtabs{$symtab_path}, '7 days'))) {
      say "FAILED to store KEY in SYMBOL TABLE CACHE for: $symtab_path"
    }
    # Store current inode in inode cache, permanently (no expiration)
    unless (defined($inode_cache
                    ->set($symtab_path,
                          $current_inodes{$symtab_path}))) {
      say "FAILED to store KEY in INODE CACHE for: $symtab_path"
    }
  }

  #say "SYMBOL TABLE KEYS IN CACHE:";
  #say join("\n", $symbol_table_cache->get_keys);

  return \%symtabs;
}


=head1 SELECTING TYPE OF DTrace SCRIPT

Specifying the <C>type<C> attribute will allow selection of the kind of DTrace
to script to activate.

=for :list
* profile
  197Hz profile for all threads in a PID
* profile_tid
  197Hz profile for a specific threads in a PID
* whatfor
  Why each thread in a PID goes off CPU
* whatfor_tid
  Why a specific thread in a PID goes off CPU

=cut

=method _build_dtrace_template_contents

Private function that selects the most appropriate DTrace script template from
those available, based on <C>type<C> attribute, among others, and returns it's
raw contents for later processing

=cut

sub _build_dtrace_template_contents {
  my ($self) = shift;

  my ($type) = $self->type;
  say "DTrace Type: $type";
  my $template = $dtrace_types{$type};

  # Log to debug log
  #say "DIST FILE:   " . dist_file('DTrace-UStackResolve', $template);
  #
  #say "MODULE FILE: " . module_file(__PACKAGE__, $template);
  #say "CLASS FILE:  " . class_file(__PACKAGE__, $template);
  #say "DIST DIR:    " . dist_dir('DTrace-UStackResolve');
  #say "MODULE DIR:  " . module_dir(__PACKAGE__);
  my ($template_path) = dist_file('DTrace-UStackResolve', $template);
  # TODO: Log to debug log
  #say "DTrace Template File: $template_path";

  my $fh = IO::File->new($template_path, "<");
  my $c = do { local $/; <$fh>; };

  return $c
}

=method _build_dtrace_script_contents

Private function that takes the DTrace template contents and resolves the
keywords, for later writing to a file.

=cut

sub _build_dtrace_script_contents {
  my ($self) = shift;

  my ($template) = $self->dtrace_template_contents();
  my ($script)   = $self->_replace_DTrace_keywords($template);

  return $script;
}

=method _replace_DTrace_keywords

This method takes a DTrace script, and replaces the keywords we recognize.

=cut

sub _replace_DTrace_keywords {
  my ($self,$script) = @_;

  my ($execname,$ustack_frames,$bufsize,$aggsize,$aggrate,$switchrate,
      $cleanrate,$dynvarsize,$nworkers,$runtime) =
    ($self->personal_execname, $self->user_stack_frames, $self->bufsize,
     $self->aggsize, $self->aggrate, $self->switchrate, $self->cleanrate,
     $self->dynvarsize,$self->nworkers,$self->runtime);

  my ($pids_aref, $tid) =
    ($self->pids, $self->tid);

  # TODO: Send below to debug output
  #say "REPLACING __EXECNAME__ with $execname";
  $script =~ s/__EXECNAME__/$execname/gsmx;
  #say "REPLACING __USTACK_FRAMES__ with $ustack_frames";
  $script =~ s/__USTACK_FRAMES__/$ustack_frames/gsmx;
  #say "REPLACING __BUFSIZE__ with $bufsize";
  $script =~ s/__BUFSIZE__/$bufsize/gsmx;
  #say "REPLACING __AGGSIZE__ with $aggsize";
  $script =~ s/__AGGSIZE__/$aggsize/gsmx;
  #say "REPLACING __AGGRATE__ with $aggrate";
  $script =~ s/__AGGRATE__/$aggrate/gsmx;
  #say "REPLACING __SWITCHRATE__ with $switchrate";
  $script =~ s/__SWITCHRATE__/$switchrate/gsmx;
  #say "REPLACING __CLEANRATE__ with $cleanrate";
  $script =~ s/__CLEANRATE__/$cleanrate/gsmx;
  #say "REPLACING __DYNVARSIZE__ with $dynvarsize";
  $script =~ s/__DYNVARSIZE__/$dynvarsize/gsmx;
  #say "REPLACING __NWORKERS__ with $nworkers";
  $script =~ s/__NWORKERS__/$nworkers/gsmx;
  #say "REPLACING __RUNTIME__ with $runtime";
  $script =~ s/__RUNTIME__/$runtime/gsmx;

  my (@pidlist_snippets, $pidlist_snippet);

  foreach my $pid (@$pids_aref) {
    push @pidlist_snippets, " ( pid == $pid ) ";
  }

  $pidlist_snippet = "( \n" . join('||', @pidlist_snippets) . "\n)";

  # Log to debug log
  #say "Build __PIDLIST__ replacement:\n$pidlist_snippet";

  $script =~ s/__PIDLIST__/$pidlist_snippet/gsmx;

  if ($tid) {
    # TODO: Log to debug log
    # say "REPLACING __TID__ with $tid";
    $script =~ s/__TID__/$tid/gsmx;
  }

  return $script;
}

sub _build_dtrace_script_fh {
  my ($self) = shift;

  my ($output_dir) = $self->output_dir;
  confess "output_dir not set yet"
    if not defined($output_dir);

  my ($script_contents) =
    $self->dtrace_script_contents;
  my ($tfh) =
    File::Temp->new( 'DTrace-Script-XXXX',
                     DIR    => $output_dir,
                   );

  $tfh->unlink_on_destroy( 0 ) if $self->preserve_tempfiles;

  $tfh->print($script_contents);
  $tfh->flush;

  return $tfh;
}


=method _start_dtrace_capture

This private method starts the DTrace script that has been chosen, and streams
the unresolved output to a file.

=cut

sub _start_dtrace_capture {
  my ($self) = shift;

  my ($DTRACE)   = $self->DTRACE;
  my ($loop)     = $self->loop;

  my ($dscript_fh)        = $self->dtrace_script_fh;
  my ($dscript_filename)  = $dscript_fh->filename;
  my ($unresolved_out_fh) = $self->dscript_unresolved_out_fh;
  my ($stderr_out_fh)     = $self->dscript_err_fh;

  my $cmd = "$DTRACE -s $dscript_filename";

  say "Going to execute: $cmd";

  my $dtrace_process =
    IO::Async::Process->new(
      command => $cmd,
      # Instead of setting up an async routine for on_read and similar, just
      # redirect the stderr/stdout to the appropriate file(s)
      setup   => [
        stdin  => [ 'open', '<',  '/dev/null'                  ],
        stdout => [ 'open', '>>', $unresolved_out_fh->filename ],
        stderr => [ 'open', '>>', $stderr_out_fh->filename     ],
      ],
      on_finish => sub {
        my ($proc_obj,$exitcode) = @_;

        my %sig_num;
        my @sig_name;

        my @names = split ' ', $Config{sig_name};
        @sig_num{@names} = split ' ', $Config{sig_num};
        foreach (@names) {
          $sig_name[$sig_num{$_}] ||= $_;
        }

        my $status = $exitcode >> 8;
        my $signal = $exitcode & 127;
        my $core_produced = $exitcode & 128;
        say "DTrace SCRIPT TERMINATED WITH STATUS: $status";
        if ($signal) {
          say "DTrace SCRIPT TERMINATED BY SIGNAL: ", $sig_name[$signal];
        }
        if ($core_produced) {
          say "DTrace SCRIPT PRODUCED A CORE DUMP";
        }

        # Doing this is probably not necessary
        # $unresolved_out_fh->close;
        # Note that DTrace has stopped.  When end of output file
        # has been reached by resolver, then exit script elsewhere, not here.
        $self->dtrace_has_exited(1);
        # This is done automatically once on_finish is complete
        #$loop->remove( $proc_obj );
        #
        # This is what we used to do:
        # At this point, DTrace has stopped producing output, but we're
        # likely not done resolving it yet - let things run...FOREVER
        # Well... Until we're done processing the unresolved output anyway.
        #$loop->stop;
      },
    );

  # Squirrel away the IO::Async::Process
  $self->dtrace_process( $dtrace_process );
  $loop->add( $dtrace_process );
  #$loop->loop_once(1);
  # TODO: Set up autoflush for STDERR
  #$dtrace_process->stderr->configure(
  #  autoflush    => 1,
  #);
}


=method start_stack_resolve

Starts up the asynchronous reading of the output of the DTrace script, and the
resolution of the user stack contained therein, and the output of this onto
STDOUT.

=cut

sub start_stack_resolve {
  my ($self) = shift;

  $obj = $self; # for use in IO::Async::FileStream callback below
  my ($unresolved_out) = $self->dscript_unresolved_out_fh->filename;
  my ($resolved_fh)    = $self->resolved_out_fh;
  my ($loop)           = $self->loop;
  my ($max_buf_pulled) = 0;  # max length of buffer pulled off of file
  # This is not yet defined - we're doing it now...
  my ($resolver_func)  =
    IO::Async::Function->new(
      init_code   => \&_init_cache,
      code        => \&_resolver,
      min_workers => 8,
      max_workers => 8,
    );
  # squirrel it away
  $self->resolver_func($resolver_func);
  # And now we can add it to the loop
  $loop->add( $resolver_func );

  # Read a "chunk of data (MUST contain *ONLY* full lines, no partials)
  # and pass this over a Channel to worker processes to actually do
  # the lookups, then get those to pass the resolved lines back over
  # another Channel to be written out to the resolved file.
  #
  # This above is all done via an IO::Async::Function automatically
  my $dtrace_unresolved_fh  = IO::File->new($unresolved_out, "<");

  # TODO: May want to think about changing this from a FileStream to just a
  #       Stream.  Keeping the FileStream for the present just for ease of
  #       debugging in the case where a stack resolution fails.
  my $filestream = IO::Async::FileStream->new(
    read_handle => $dtrace_unresolved_fh,
    read_len    => 1024 * 1024,  # 1 MB rather than 8 KB max reads
    read_all    => 1,

    on_read => sub {
      my ( $self, $buffref, $eof ) = @_;

      #while ( $$buffref =~ s/^(.*)\n// ) {
      while ( $$buffref =~ s/(.+\n)//smx ) {
        $max_buf_pulled = (length($1) > $max_buf_pulled) ?
                           length($1)                    :
                           $max_buf_pulled;
        my (@chunks);
        my $c = $1;
        @chunks = $c =~ m{ ( (?: ^ [^\n]+? \n|^\n) {1,500} ) }gsmx;

        my $f = fmap {
          my ($chunk) = @_;
          $resolver_func->call( args => [ $chunk ] );
        } foreach => \@chunks,
          concurrent => 8;

        my (@resolved_chunks) = $f->get;
        foreach my $chunk (@resolved_chunks) {
          $resolved_fh->print($chunk);
        }

      }

      # For a FileStream, $eof will be set every time we reach the end of the
      # file, but we'll continue to watch for changes, UNLESS we know the DTrace
      # script that's producing output into the UNRESOLVED file has exited, in
      # which case we know we're *really* done.
      if ($eof) {
        if ($obj->dtrace_has_exited) {
          say "MAX BUFFER PULLED FROM FILE: $max_buf_pulled";
          say "DTrace Script has exited, and read everything it produced - EXITING";
          $resolved_fh->close;
          # Shut down worker processes/threads
          $resolver_func->stop;
          # NOTE: Added once we moved to IO::Async::Function
          $loop->stop;
        }
      }

      return 0;
    },
  );

  $loop->add( $filestream );
}

#
# UTILITY FUNCTIONS - NOT to be called as object methods, but as Future loops
#
sub _pid_dynamic_library_paths {
  my ($pid) = shift;

  # NOTE: It's likely we don't need to bother caching this, as it's really
  #       quick.
  my @pids = ( $pid );
  my $PLDD = __PACKAGE__->PLDD;
  my %libpath_map;

  # Dynamic .so library analysis
  my $pldd_so_regex =
    qr{
       ^ (?<libpath>/[^\n]+?\.so(?:[^\n]+|)) \n # Absolute path only
      }smx;

  foreach my $pid (@pids) {
    my $pldd_output = capture( "$PLDD $pid" );
    while ($pldd_output =~ m{$pldd_so_regex}gsmx) {
      $libpath_map{$+{libpath}}++;
    }
  }

  # Return the list of absolute library paths
  return [ keys %libpath_map ];
}

sub _get_pid_start_epoch {
  my ($self,$pid) = @_;

  my ($st);

  unless ($st = stat("/proc/$pid")) {
    carp "PID file /proc/$pid missing: $!";
    return;
  }
  return $st->ctime;
}

sub _file_sha1_digest {
  my ($self,$file) = @_;

  my $fh   = IO::File->new($file,"<");
  unless (defined $fh) {
    carp "$file does not exist: $!";
    return;
  }
  my $sha1 = Digest::SHA1->new;

  $sha1->addfile($fh);
  my $digest = $sha1->hexdigest;
  say "SHA-1 of $file is: $digest";
  return $digest;
}

sub _gen_symbol_table {
  # Given a path to an executable, generate the symbol table.
  # The #pragma for noresolve ensures each generated symbol will be of the
  # form <entity>:<offset from base of entity>
  #
  # This means that we can use the symbol table with base address assumed to be
  # implicitly 0 to resolve symbols without further work.
  #
  my ($exec_or_lib_path, $exec_or_lib_sha1) = @_;
  # $start_offset is the offset of the _START_ symbol in a library or exec
  my ($symtab_aref,$symcount,$_start_offset);

  my $elf_type = __PACKAGE__->_elf_type($exec_or_lib_path);
  if ($elf_type eq "ET_EXEC") {
    $symtab_aref = __PACKAGE__->_exec_symbol_tuples($exec_or_lib_path);
  } elsif ($elf_type eq "ET_DYN") {
    $symtab_aref = __PACKAGE__->_dyn_symbol_tuples($exec_or_lib_path);
  } else {
    say "[$exec_or_lib_path] is ELF Type $elf_type: SKIPPING";
  }

  $symcount = scalar(@$symtab_aref);
  say "$exec_or_lib_path: EXTRACTED TOTAL OF $symcount SYMBOLS";

  return $symtab_aref;
}



# Grab ELF Type:
# - ET_EXEC for a.out
# - ET_DYN  for dynamic library
# Ignore all else
sub _elf_type {
  my ($self, $file) = @_;

  my ($ELFDUMP) = $self->ELFDUMP;
  my $out = capture("$ELFDUMP -e $file");

  #say $out;
  $out =~ m/^ \s+ e_type: \s+ (?<elf_type>[^\n]+)/smx;

  my $elf_type = $+{elf_type};

  #say "[$file] ELF Type: $elf_type";

  return $elf_type;
}

# Get list of symbol tuples from a given file, properly offset
sub _exec_symbol_tuples {
  my ($self, $file) = @_;

  # TODO:
  # If the symbol table file map already contains this file, skip it
  # return if exists($symbols{$file});
  #
  # NOTE: The base address for all a.out's is identical across all instances of
  # the executable running.  Thus, we only need to do this once, and make sure
  # all instances are loaded from the exact same file to know our lookups will
  # always be good.

  # Extract load address from the ELF file
  my $load_address = $self->_get_exec_load_address($file);

  # Extract symbol table
  # TODO: fix extract_symtab so it can accept an object or __PACKAGE__ (class)
  #       name
  my $function_tuples = DTrace::UStackResolve::extract_symtab($file);

  if ($load_address == 0) {
    say "NO NEED TO ADJUST OFFSETS FOR SYMBOLS IN: $file";
  } else {
    say "ADJUSTING SYMBOLS IN: $file, BY LOAD ADDRESS $load_address";
    foreach my $tuple (@$function_tuples) {
      # Only want to do this if the result won't be negative
      if (($tuple->[$FUNCTION_START_ADDRESS] - $load_address) <= 0) {
        say "UNABLE TO ADJUST OFFSET " . $tuple->[$FUNCTION_START_ADDRESS] .
            " for " . $tuple->[$FUNCTION_NAME];
      } else {
        $tuple->[$FUNCTION_START_ADDRESS] -= $load_address;
      }
    }
  }
  return $function_tuples
}

# Get a.out load address
sub _get_exec_load_address {
  my ($self, $file) = @_;

  my ($ELFDUMP) = $self->ELFDUMP;
  my $out = capture("$ELFDUMP -p $file");

  if ($out =~ m/ \s+ p_vaddr: \s+ (?<load_address_in_hex>\S+) \s+ [^\n]+\n
                 [^\n]+ p_type: \s+ \[ \s+ PT_LOAD \s+ \]/smx) {
    # We're all good
  } else {
    # SOMETHING IS WRONG
    say "UNABLE TO FIND FIRST PT_LOAD PROGRAM HEADER";
    return; # undef
  }
  my $hex_load_address = $+{load_address_in_hex};
  # Note that we use Math::BigInt here to avoid warnings
  my $load_address     = Math::BigInt->from_hex($hex_load_address)->numify;

  say "LOAD ADDRESS (hex): " . $hex_load_address;
  say "LOAD ADDRESS (dec): " . $load_address;
  return $load_address;
}

# Get list of dynamic library symbol tuples
sub _dyn_symbol_tuples {
  my ($self, $file) = @_;

  # TODO:
  # If the symbol table file map already contains this file, skip it
  # return if exists($symbols{$file});

  # NOTE: Load address for dynamic object not needed - DTrace helps us out
  # there in the unresolved ustack() output by prefixing the addresses by the
  # implied base address.  So we don't even have to keep a table of the base
  # addresses of these per PID.  Yahoo!

  # Extract symbol table
  # TODO: May want to call these in parallel via an IO::Async Function
  my $function_tuples = DTrace::UStackResolve::extract_symtab($file);

  return $function_tuples;
}

=method _init_cache

Initialize the following caches:

The various file symbol tables, each in the form of a Red Black Tree - this
is actually just re-opening the previously generated cache.

The "direct lookup" cache, which is a RAM cache to store the most commonly
discovered raw entries in the unresolved stack output, so that they won't
have to be looked up in the Red Black Tree as often.

=cut

sub _init_cache {
  # $obj is a closure for the top level __PACKAGE__ object instance that was
  # passed in from start_stack_resolve
  my ($output_dir) = $obj->output_dir;

  my ($RB_cache) =
    CHI->new(
      driver       => 'BerkeleyDB',
      # No size specified
      # cache_size   => '8m',
      root_dir     => File::Spec->catfile( $output_dir, 'symbol_tables' ),
      namespace    => 'RedBlack_tree_symbol',
      global       => 0,
      on_get_error => 'warn',
      on_set_error => 'warn',
      l1_cache     => { driver   => 'RawMemory',
                        global   => 0,
                        # This is in terms of items, not bytes!
                        max_size => 128*1024,
                      }
    );

  $worker_direct_symbol_cache =
    CHI->new(
      driver       => 'RawMemory',
      # This is in terms of item count, not bytes!
      max_size     => 8*1024,
      global       => 0,
    );

  my $RB_keys_aref = [ $RB_cache->get_keys ];
  $worker_symtab_trees_href =
    $RB_cache->get_multi_hashref($RB_keys_aref);
  # Determine if annotations will be printed for non-resolvable symbols
  $no_annotations    = $obj->no_annotations;
  # ... and whether direct lookups are enabled
  $do_direct_lookups = $obj->do_direct_lookups;
}

=method _resolver( $chunk_of_unresolved_lines )

Given a chunk of complete lines from the unresolved stack output, resolve any
symbols needing it.

If a symbol cannot be resolved, annotate the line accordingly.

For any lines where there is no symbol to be resolved, return the line
unchanged.

=cut


sub _resolver {
  my ($chunk) = @_;

  my ($resolved_chunk,$cached_result);
  my $unresolved_re =
    qr/^(?<keyfile>[^:]+):0x(?<offset>[\da-fA-F]+)/;

  while ( $chunk =~ s/^(.*)\n// ) {
    my $line = $1;
    if ($line =~ m/^(?<keyfile>[^:]+):0x(?<offset>[\da-fA-F]+)$/) {
      # Return direct lookup if enabled and available
      if ($do_direct_lookups and
          ($cached_result = $worker_direct_symbol_cache->get($line))) {
        $line = $cached_result;
      } else {
        # Otherwise look up the symbol via the specified manner
        my ($keyfile, $offset) = ( $+{keyfile},
                                   Math::BigInt->from_hex( $+{offset} )->numify
                                 );
        # TODO: Add lookup_type in proper scope
        if ($lookup_type == "RedBlack") {
          $line = _lookup_RB($line, $keyfile, $offset);
        } else {
          $line = _lookup_BinarySearch($line, $keyfile, $offset);
        }

        #if ( defined( my $search_tree = $worker_symtab_trees_href->{$keyfile} ) ) {
        #  my $symtab_entry = $search_tree->lookup( $offset, LULTEQ );
        #  if (defined($symtab_entry)) {
        #    if (($offset >= $symtab_entry->[$FUNCTION_START_ADDRESS] ) and
        #        ($offset <= ($symtab_entry->[$FUNCTION_START_ADDRESS] +
        #                     $symtab_entry->[$FUNCTION_SIZE]) ) ) {
        #      my $resolved =
        #        sprintf("%s+0x%x",
        #                $symtab_entry->[$FUNCTION_NAME],
        #                $offset - $symtab_entry->[$FUNCTION_START_ADDRESS]);
        #      # If we got here, we have something to store in the direct symbol
        #      # lookup cache
        #      $worker_direct_symbol_cache->set($line,$resolved);
        #      $line =~ s/^(?<keyfile>[^:]+):0x(?<offset>[\da-fA-F]+)$/${resolved}/;
        #    } else {
        #      if (not $no_annotations) {
        #        $line .= " [SYMBOL TABLE LOOKUP FAILED - POTENTIAL MATCH FAILED]";
        #      }
        #    }
        #  } else {
        #    if (not $no_annotations) {
        #      $line .= " [SYMBOL TABLE LOOKUP FAILED - NOT EVEN A POTENTIAL MATCH]";
        #    }
        #    #say "FAILED TO LOOKUP ENTRY FOR: $keyfile";
        #    #confess "WHAT THE HECK HAPPENED???";
        #  }
        #} else {
        #  if (not $no_annotations) {
        #    $line .= " [NO SYMBOL TABLE FOR $keyfile]";
        #  }
        #}
      }
    }
    $resolved_chunk .= "$line\n";
  }

  return $resolved_chunk;
}

sub _lookup_RB {
  my ($line,$keyfile,$offset) = @_;

  # Look up the symbol in the RB Tree
  if ( defined( my $search_tree = $worker_symtab_trees_href->{$keyfile} ) ) {
    my $symtab_entry = $search_tree->lookup( $offset, LULTEQ );
    if (defined($symtab_entry)) {
      if (($offset >= $symtab_entry->[$FUNCTION_START_ADDRESS] ) and
          ($offset <= ($symtab_entry->[$FUNCTION_START_ADDRESS] +
                       $symtab_entry->[$FUNCTION_SIZE]) ) ) {
        my $resolved =
          sprintf("%s+0x%x",
                  $symtab_entry->[$FUNCTION_NAME],
                  $offset - $symtab_entry->[$FUNCTION_START_ADDRESS]);
        # If we got here, we have something to store in the direct symbol
        # lookup cache
        $worker_direct_symbol_cache->set($line,$resolved);
        $line =~ s/^(?<keyfile>[^:]+):0x(?<offset>[\da-fA-F]+)$/${resolved}/;
      } else {
        if (not $no_annotations) {
          $line .= " [SYMBOL TABLE LOOKUP FAILED - POTENTIAL MATCH FAILED]";
        }
      }
    } else {
      if (not $no_annotations) {
        $line .= " [SYMBOL TABLE LOOKUP FAILED - NOT EVEN A POTENTIAL MATCH]";
      }
      #say "FAILED TO LOOKUP ENTRY FOR: $keyfile";
      #confess "WHAT THE HECK HAPPENED???";
    }
  } else {
    if (not $no_annotations) {
      $line .= " [NO SYMBOL TABLE FOR $keyfile]";
    }
  }
}

sub _lookup_BinarySearch {
  my ($line,$keyfile,$offset) = @_;

  # Look up the symbol in the proper symtab sorted array via Binary Search
  # TODO: substitute proper tree for worker_symtab_trees_href
  if ( defined( my $search_tree = $worker_symtab_trees_href->{$keyfile} ) ) {
    my $symtab_entry = $search_tree->lookup( $offset, LULTEQ );
    if (defined($symtab_entry)) {
      if (($offset >= $symtab_entry->[$FUNCTION_START_ADDRESS] ) and
          ($offset <= ($symtab_entry->[$FUNCTION_START_ADDRESS] +
                       $symtab_entry->[$FUNCTION_SIZE]) ) ) {
        my $resolved =
          sprintf("%s+0x%x",
                  $symtab_entry->[$FUNCTION_NAME],
                  $offset - $symtab_entry->[$FUNCTION_START_ADDRESS]);
        # If we got here, we have something to store in the direct symbol
        # lookup cache
        $worker_direct_symbol_cache->set($line,$resolved);
        $line =~ s/^(?<keyfile>[^:]+):0x(?<offset>[\da-fA-F]+)$/${resolved}/;
      } else {
        if (not $no_annotations) {
          $line .= " [SYMBOL TABLE LOOKUP FAILED - POTENTIAL MATCH FAILED]";
        }
      }
    } else {
      if (not $no_annotations) {
        $line .= " [SYMBOL TABLE LOOKUP FAILED - NOT EVEN A POTENTIAL MATCH]";
      }
      #say "FAILED TO LOOKUP ENTRY FOR: $keyfile";
      #confess "WHAT THE HECK HAPPENED???";
    }
  } else {
    if (not $no_annotations) {
      $line .= " [NO SYMBOL TABLE FOR $keyfile]";
    }
  }
}

=head1 FUNCTIONS

This section describes the interface to the underlying XS interface to libproc.

=head2 extract_symtab("/path/to/exec/or/lib")

This is the function that takes the name of any executable (a.out) or dynamic
library, and returns the symbol table as an array ref of hashrefs.

Each hash reference contains the following keys:

  {
    function => I<function name>,
    start    => I<start address>,
    start    => I<size of function>
  }

Usage:

  my $symtab_aref = DTrace::UStackResolve::extract_symtab("/lib/libc.so.1");

=cut

1;
